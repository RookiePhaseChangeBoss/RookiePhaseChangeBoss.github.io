---
title: "1. Docker 教程"
date: 2026-01-06 14:15 +0800
categories: [Docker, Image & Container]   # 分类（支持多级）
tags: [Docker]               				# 标签（不限数量）
description: "讲解 Docker 最近的知识点"
author: "YoungZhongque"
pin: false                             		# 是否置顶（true / false）

# 封面图（社交媒体预览图最佳尺寸 1200x630）
# image:
  # path: /assets/img/sample-cover.jpg     # 站点内路径
  # alt: "封面图描述"
  # lqip: /assets/img/lqip/sample.jpg      # （可选）低质量占位图

# 是否启用目录（左侧浮动目录）
toc: true
toc_label: "目录"
toc_icon: "list-ul"

# 文章版权 / 转载声明（可选）
copyright:
  license: CC BY-NC-SA 4.0
  holder: "YoungZhongque"
---


本笔记来源: [菜鸟教程- Docker 教程](https://www.runoob.com/docker/docker-tutorial.html) 

应用场景:

- **微服务架构：**每个服务独立容器化，便于管理和扩展
- **CI/CD流水线：**与 Jenkins/GitLab CI 集成，实现自动化构建和测试
- **开发环境标准化：**新成员一键启动全套依赖服务（如数据库, 消息队列）
- **云原生基础：**Kubernetes 等编排工具基于 Docker 管理容器集群

基本命令:

```bash
# 拉取镜像（如官方Nginx镜像）
docker pull nginx

# 运行容器（-d 后台运行，-p 映射端口）
docker run -d -p 80:80 nginx

# 查看运行中的容器
docker ps

# 构建镜像（基于当前目录的Dockerfile）
docker build -t my-app .

# 进入容器内部
docker exec -it <容器ID> /bin/bash
```

## 1. Docker 基础概念

### 1.1. 容器化技术

容器共享主机内核，轻量, 隔离且高效：

- 上层: 多个容器 (App A~F), 每个容器独立运行一个应用
- 中间层: Docker - 管理容器
- 底层: 主机操作系统 (Host OS) 和基础设施, 为容器提供硬件和系统支持

<img src="https://www.runoob.com/wp-content/uploads/2025/05/d7d5638a-d0fe-45a4-8a67-59a21f4318d6.png" alt="img" style="zoom:33%;" />

<center>Docker 容器基本架构</center>

容器化的核心理念：

- 应用和环境被打包成不可变的镜像
- 每次部署都使用相同的镜像
- 配置通过环境变量或配置文件注入
- 问题修复通过重新构建镜像而非修改运行中的容器



### 1.2. Docker 核心概念

**1. 镜像(Image)** 

- **分层存储**：镜像由多个层组成，每一层代表一次修改 
- **只读性** 
- **可复用**：同一个镜像可以创建多个容器
- **版本管理**：通过标签(tag)进行版本管理

**2. 容器 (Container)** 

- **隔离性**：每个容器都有自己的文件系统, 网络和进程空间
- **临时性** 
- **可写层**：容器在镜像基础上添加了一个可写层
- **进程级**：容器内通常运行一个主进程

**3. 仓库 (Repository)** 

- **公共仓库**：如 Docker Hub，任何人都可以使用
- **私有仓库**：企业内部搭建，用于存储私有镜像
- **官方仓库**：由软件官方维护的镜像仓库

**Registry vs Repository**：

- **Registry**：仓库注册服务器，如 Docker Hub
- **Repository**：具体的镜像仓库，如 nginx, mysql

### 1.3. Docker 与虚拟机的区别

**1. 架构对比** 

|   特性   |        虚拟机        |     Docker容器     |
| :------: | :------------------: | :----------------: |
| 隔离级别 |    硬件级别虚拟化    | 操作系统级别虚拟化 |
| 操作系统 |   每个VM需要完整OS   |  共享宿主机OS内核  |
| 资源占用 | 重量级，占用较多资源 | 轻量级，资源占用少 |
| 启动时间 |       分钟级别       |       秒级别       |
| 性能开销 |         较大         |    接近原生性能    |
| 镜像大小 |        GB级别        |       MB级别       |



**2. 容 VS 虚拟机架构** 

<img src="https://www.runoob.com/wp-content/uploads/2025/05/1_choU2ZN14HZThwbqRFzlHg.png" alt="img" style="zoom: 67%;" />

**3. 使用场景**

虚拟机适用场景：

- 需要完全隔离的环境
- 运行不同操作系统的应用
- 需要硬件级别的安全隔离

Docker容器适用场景：

- 微服务架构
- CI/CD流水线
- 应用快速部署和扩展
- 开发环境标准化



### 1.4. Docker 架构组件

**整体架构** 

<img src="https://www.runoob.com/wp-content/uploads/2025/05/screenshot-2023-01-16-at-110130.png" alt="img" style="zoom: 67%;" />

**Docker Client**

- **功能**：

  - 用户与 Docker 交互
  - 接收用户命令并发送给 Docker Daemon

  - 可以与远程 Docker Daemon 通信

- **常用命令**：

  - `docker run` - 运行容器

  - `docker build` - 构建镜像

  - `docker pull` - 拉取镜像

  - `docker ps` - 查看容器状态

**Docker Daemon**

- **功能**：

  - Docker 的核心服务进程

  - 管理镜像, 容器, 网络, 存储卷

  - 监听 Docker API 请求并处理

- **主要职责**：

  - 镜像管理 (构建, 存储, 分发)

  - 容器生命周期管理

  - 网络管理

  - 数据卷管理

  - 与 Registry 通信

**Docker Engine**

- **组成**：

  - Docker Client + Docker Daemon + REST API

  - Docker 核心组件

- **工作流程**：
  1. Client 发送命令到 Daemon
  2. Daemon 解析并执行命令
  3. 与 Registry 交互 (如需要)
  4. 管理本地镜像和容器
  5. 返回结果给 Client

**Docker Registry** 

- **作用**：

  - 存储和分发Docker镜像

  - 提供镜像的版本管理

  - 支持公有和私有仓库

**Docker Hub特点**：

- 官方公共 Registry
- 包含大量预构建镜像
- 支持自动构建功能
- 免费和付费服务

## 2. Docker 架构

### 2.1. Docker 架构: 

- 基于客户端-服务器模式, 包括多个关键组件, 确保容器化应用的高效构建、管理和运行
- 设计使得开发者能将应用程序与其所有依赖封装在一个可移植的容器中, 并在不同的环境中一致地运行
- 使用客户端-服务器 (C/S) 架构模式, 使用远程 API 来管理和创建 Docker 容器

### 2.2. 架构示意图

<img src="https://www.runoob.com/wp-content/uploads/2016/07/docker-architecture.webp" alt="img" style="zoom:67%;" />

### 2.3. Docker 架构的工作流程

- **构建镜像**：使用 `Dockerfile` 创建镜像
- **推送镜像到注册表**：将镜像上传到 Docker Hub 或私有注册表中
- **拉取镜像**：通过 `docker pull` 从注册表中拉取镜像。
- **运行容器**：使用镜像创建并启动容器
- **管理容器**：使用 Docker 客户端命令管理正在运行的容器 (例如查看日志、停止容器、查看资源使用情况等)
- **网络与存储**：容器之间通过 Docker 网络连接，数据通过 Docker 卷或绑定挂载进行持久化

### 2.4. Docker 客户端 (Docker Client)

用户与 Docker 守护进程交互的命令行界面 (CLI). 是用户与 Docker 系统的主要交互方式, 用户通过 Docker CLI 发出命令, 这些命令被发送到 Docker 守护进程, 由守护进程执行相应的操作

- **功能**：允许用户使用命令与 Docker 守护进程通信, 如创建容器, 构建镜像, 查看容器状态等
- **交互方式**：Docker 客户端与 Docker 守护进程之间通过 `REST API` 或 `Unix` 套接字通信。常用的命令行工具是 `docker`，通过它，用户可以发出各种 Docker 操作命令。(<font color = "#008000">什么是 `REST API` or `Unix` 套接字</font>)

常用命令：

- `docker run`：运行容器
- `docker ps`：列出正在运行的容器
- `docker build`：构建 Docker 镜像
- `docker exec`：在容器中执行命令

### 2.5. Docker 守护进程 (Docker Daemon)

Docker 守护进程（通常是 `dockerd`）是 Docker 架构的核心，负责管理容器生命周期、构建镜像、分发镜像等。

守护进程以后台进程的方式运行，等待来自 Docker 客户端的 API 请求。

**功能**：

- 启动和停止容器
- 构建、拉取和推送镜像
- 管理容器的网络和存储
- 启动、停止、查看容器日志等
- 与 Docker 注册表进行通信, 管理镜像的存储与分发

Docker 守护进程监听 Docker 客户端的请求, 通过 Docker API 执行这些请求. 守护进程将负责容器、镜像等 Docker 对象的管理，根据请求的参数启动容器、删除容器、修改容器配置等。

启动 Docker 守护进程（通常是自动启动的）：

```bash
sudo systemctl start docker
```

### 2.6. Docker 引擎 API (Docker Engine API)

Docker 提供的 RESTful 接口, 允许外部客户端与 Docker 守护进程进行通信. 通过这个 API, 用户可以执行各种操作: 如启动容器, 构建镜像, 查看容器状态. <u>API 提供了 HTTP 请求的接口, 支持跨平台调用</u>. 

**功能**: 

- 向 Docker 守护进程发送 HTTP 请求; 实现容器, 镜像的管理.
- 提供 RESTful 接口，允许通过编程与 Docker 进行交互。

可以通过 `curl` 或其他 HTTP 客户端访问 Docker 引擎 API。例如，查询当前 Docker 守护进程的版本：

```shell
curl --unix-socket /var/run/docker.sock http://localhost/version
```

### 2.7. Docker 容器 (Docker Containers)

Docker 的执行环境; 轻量级, 独立且可执行的软件包. 从 Docker 镜像启动, 包含运行某个应用程序所需的一切 —— 从操作系统库到应用程序代码. 容器在运行时与其他容器和宿主机共享操作系统内核, 但容器之间的文件系统和进程相互隔离. 

**功能**：

- 提供独立的运行环境, 确保应用程序在不同的环境中有一致行为
- 容器是临时的，通常在任务完成后被销毁

容器的生命周期由 Docker 守护进程管理. 容器可在任何地方运行, 因为它们不依赖于底层操作系统的配置, 所有的运行时依赖已经封装在镜像中。

启动一个容器：

```bash
docker run -d ubuntu
```

### 2.8. Docker 镜像 (Docker Images)

是容器的只读模板. 每个镜像都包含了应用程序运行所需的操作系统、运行时、库、环境变量和应用代码等. 镜像是静态的，用户可以根据镜像启动容器。

**功能**：

- 镜像是构建容器的基础，每个容器实例化时都会使用镜像。
- 镜像是只读的，不同容器使用同一个镜像时，容器中的文件系统层是独立的。

Docker 镜像可以通过 `docker pull` 从 Docker Hub 或私有注册表拉取，也可以通过 `docker build` 从 Dockerfile 构建。

拉取 Ubuntu 镜像：

```bash
docker pull ubuntu
```

### 2.9. Docker 仓库 (Docker Registries)

用来存储 Docker 镜像, 最常用的公共仓库是 **Docker Hub**. 可从 Docker Hub 下载镜像, 也可上传自己的镜像. 除了公共仓库，可部署私有 Docker 仓库来管理镜像. 

**功能**：

- 存储 Docker 镜像
- 提供镜像的上传和下载功能

Docker Hub 提供了大量官方和社区维护的镜像, 如 Ubuntu、Nginx、MySQL 等

推送镜像到 Docker Hub：

```
docker push <username>/<image_name>
```

### 2.10. Docker Compose

一个用于定义和运行多容器 Docker 应用的工具; 可使用 `docker-compose.yml` 配置文件定义多个容器 (服务) & 通过一个命令启动这些容器. 主要用于开发, 测试, 部署多容器的应用. 

**功能**：

- 定义和运行多个容器组成的应用
- 通过 YAML 文件来配置应用的服务, 网络和卷等

创建一个简单的 `docker-compose.yml` 文件来配置一个包含 Web 服务和数据库服务的应用：

```
version: '3'
services:
  web:
    image: nginx
    ports:
      - "8080:80"
  db:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: example
```

启动 Compose 定义的所有服务：

```
docker-compose up
```

### 2.11. Docker Swarm

Docker 提供的集群管理和调度工具. 允许将多个 Docker 主机 (节点) 组织成一个集群, 通过 Swarm 集群管理工具来调度和管理容器. Swarm 可以实现容器的负载均衡、高可用性和自动扩展等功能。

**功能**：

- 管理多节点 Docker 集群。
- 通过调度器管理容器的部署和扩展。

初始化 Swarm 集群：

```
docker swarm init
```

PS: <font color = "#00800">需要详细了解</font>

### 2.12. Docker 网络 (Docker Networks)

允许容器之间相互通信, 与外部世界进行连接. Docker 提供了多种网络模式来满足不同的需求，如 `bridge` 网络（默认）、`host` 网络和 `overlay` 网络

**功能**：

- 管理容器间的网络通信。
- 支持不同的网络模式，以适应不同场景下的需求。

创建一个自定义网络并将容器连接到该网络：

```
docker network create my_network
docker run -d --network my_network ubuntu
```

PS: <font color = "#00800">需要详细了解</font> 

### 2.13. Docker 卷 (Docker Volumes)

Docker 卷是一种数据持久化机制，允许数据在容器之间共享，并且独立于容器的生命周期。与容器文件系统不同，卷的内容不会随着容器的销毁而丢失，适用于数据库等需要持久存储的应用。

**功能**：

- 允许容器间共享数据。
- 保证数据持久化，独立于容器的生命周期。

创建并挂载卷：

```
docker volume create my_volume
docker run -d -v my_volume:/data ubuntu
```

PS: <font color = "#00800">需要详细了解</font> 

































